{% extends 'base.html' %}
{% block content %}
    <h2 class="text-xl font-semibold mb-4">Driver Dashboard</h2>
    <p>Welcome, {{ request.user.username }}.</p>
    <p>Vehicle Number: {{ driver.vehicle_number }}</p>

    {% if driver.verified %}
        {% if route and bus %}
            <div class="mt-4">
                <button id="startTracking" class="bg-green-500 text-white p-2 rounded">Start Tracking</button>
                <button id="stopTracking" class="bg-red-500 text-white p-2 rounded" disabled>Stop Tracking</button>
            </div>
            <p id="trackingStatus" class="mt-4"></p>
            <h3 class="text-lg font-semibold mt-6 mb-2">Seat Arrangement ({{ bus.total_seats }} seats)</h3>
            <div id="seatGrid" class="grid gap-2" style="grid-template-columns: repeat(5, 40px); max-width: 220px;">
                {% for seat, col in seat_grid_columns %}
                    {% if forloop.counter0|divisibleby:4 and forloop.counter0 < last_row_start %}
                        <div style="grid-column: 1 / span 5; height: 5px;"></div>
                    {% endif %}
                    <button class="seat-btn {% if seat.is_available %}bg-green-400{% else %}bg-red-500{% endif %} text-white rounded w-10 h-10 focus:outline-none" 
                        data-seat-id="{{ seat.id }}" 
                        style="grid-column: {{ col }};"
                        >{{ seat.seat_number }}</button>
                {% endfor %}
            </div>
            <div class="text-sm text-gray-600 mt-2">Click a seat to toggle availability (green = available, red = occupied).</div>
            <div class="mt-6">
                <h4 class="font-semibold">Notifications <span id="notifBadge" style="background:#ef4444;color:#fff;padding:2px 8px;border-radius:999px;margin-left:8px;display:none;">0</span>
                    <button id="clearAllNotifs" class="ml-4 bg-gray-200 text-gray-800 p-1 rounded text-sm">Clear all</button>
                </h4>
                <div id="driverNotifications" style="border:1px solid #eee; padding:8px; height:120px; overflow:auto;"></div>
            </div>
            <div class="mt-6">
                <h4 class="font-semibold">Chat with Passenger</h4>
                <div id="driverChatLog" style="height:160px; overflow:auto; border:1px solid #ddd; padding:8px; background:#fafafa;"></div>
                <div class="mt-2">
                    <input id="driverChatInput" placeholder="Type message" class="p-2 border rounded w-3/4" />
                    <button id="driverSendChat" class="bg-blue-600 text-white p-2 rounded">Send</button>
                </div>
            </div>
        {% elif route and not bus %}
            <form method="post" class="mt-4">
                {% csrf_token %}
                <label class="block mb-2">Total Seats:
                    <input type="number" name="total_seats" min="10" max="60" value="25" class="p-2 border rounded w-24" required>
                </label>
                <label class="block mb-2">Bus Number Plate:
                    <input type="text" name="number_plate" class="p-2 border rounded w-40" required>
                </label>
                <button type="submit" class="bg-blue-500 text-white p-2 rounded">Create Bus</button>
            </form>
        {% else %}
            <p class="text-red-500 mt-4">No route assigned. Please contact admin.</p>
        {% endif %}
    {% else %}
        <p>Your account is pending admin verification.</p>
    {% endif %}


<script>
{% if route and bus %}
let socket;
let geoWatchId = null;
const busId = "{{ route.id }}";
const startBtn = document.getElementById('startTracking');
const stopBtn = document.getElementById('stopTracking');
const status = document.getElementById('trackingStatus');

startBtn.addEventListener('click', function(){
    if (socket && socket.readyState === WebSocket.OPEN) return;
    const wsUrl = 'ws://' + window.location.host + '/ws/location/' + busId + '/';
    socket = new WebSocket(wsUrl);
    socket.onopen = function(){
        status.innerText = "Tracking started.";
        startBtn.disabled = true;
        stopBtn.disabled = false;
        // Start sending geolocation
        if (navigator.geolocation) {
            geoWatchId = navigator.geolocation.watchPosition(function(position) {
                const data = {
                    lat: position.coords.latitude,
                    lng: position.coords.longitude
                };
                console.log("Sending location:", data);
                socket.send(JSON.stringify(data));
            }, function(error) {
                status.innerText = "Geolocation error: " + error.message;
                console.error("Geolocation error:", error);
            }, { enableHighAccuracy: true });
        } else {
            status.innerText = "Geolocation is not supported by this browser.";
            console.error("Geolocation is not supported by this browser.");
        }
    };
    socket.onerror = function(error){
        status.innerText = "WebSocket error. See console.";
        console.error("WebSocket error:", error);
    };
    socket.onclose = function(){
        status.innerText = "Tracking stopped.";
        startBtn.disabled = false;
        
        stopBtn.disabled = true;
        if (geoWatchId !== null) {
            navigator.geolocation.clearWatch(geoWatchId);
            geoWatchId = null;
        }
    };
});

stopBtn.addEventListener('click', function(){
    if (socket) {
        socket.close();
    }
    if (geoWatchId !== null) {
        navigator.geolocation.clearWatch(geoWatchId);
        geoWatchId = null;
    }
    status.innerText = "Tracking stopped.";
    startBtn.disabled = false;
    stopBtn.disabled = true;
});
stopBtn.disabled = true;

// Seat toggle logic
document.querySelectorAll('.seat-btn').forEach(function(btn) {
    btn.addEventListener('click', function() {
        const seatId = this.getAttribute('data-seat-id');
        fetch('/api/toggle_seat/', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': '{{ csrf_token }}',
            },
            body: JSON.stringify({ seat_id: seatId })
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                if (data.is_available) {
                    this.classList.remove('bg-red-500');
                    this.classList.add('bg-green-400');
                } else {
                    this.classList.remove('bg-green-400');
                    this.classList.add('bg-red-500');
                }
            }
        });
    });
});
{% endif %}

// Driver websocket for notifications and chat (separate, not nested in socket.onclose)
{% if request.user.is_authenticated and request.user.driver_profile %}
    (function(){
        const driverId = {{ request.user.id }};
        const chatRoom = 'driver_' + driverId; // connect to driver-specific room
        const driverSocket = new WebSocket((location.protocol === 'https:' ? 'wss://' : 'ws://') + window.location.host + '/ws/chat/' + chatRoom + '/');
        const notifBox = document.getElementById('driverNotifications');
        const notifBadge = document.getElementById('notifBadge');

        // Helper to update badge
        function setBadge(count){
            if (!notifBadge) return;
            if (count && count > 0) {
                notifBadge.innerText = count;
                notifBadge.style.display = 'inline-block';
            } else {
                notifBadge.style.display = 'none';
            }
        }

        // Fetch initial unread pickup count
        fetch('/driver/notifications/').then(r=>r.json()).then(data=>{
            if (data && typeof data.unread_count !== 'undefined') setBadge(data.unread_count);
            // optionally preload recent pickups into the box
            if (data.recent && Array.isArray(data.recent)){
                data.recent.forEach(function(p){
                    console.log('Preloaded pickup payload:', p);
                    const rawUsername = p.user || null;
                    const username = rawUsername && !rawUsername.startsWith('user_') ? rawUsername : null;
                    const display = username ? username : ('User #' + p.user_id);
                    const el = document.createElement('div');
                    el.innerText = `Pickup from ${display} at ${p.stop}: ${p.message}`;
                    el.setAttribute('data-pickup-id', p.id);
                    el.setAttribute('data-user-id', p.user_id);
                    if (username) el.setAttribute('data-username', username);
                    el.style.cursor = 'pointer';
                    el.addEventListener('click', onNotifClick);
                    notifBox.appendChild(el);
                });
            }
        }).catch(()=>{});
        const chatLog = document.getElementById('driverChatLog');
        const chatInput = document.getElementById('driverChatInput');
        const sendBtn = document.getElementById('driverSendChat');

        driverSocket.onmessage = function(e){
            const d = JSON.parse(e.data);
            console.log('Driver WS message received:', d);
            if (d.type === 'pickup_notification') {
                const el = document.createElement('div');
                const rawUsername = d.user_username || null;
                const username = rawUsername && !rawUsername.startsWith('user_') ? rawUsername : null;
                const displayName = username ? username : ('User #' + d.user_id);
                el.innerText = `Pickup from ${displayName} for bus ${d.bus_id} at ${d.stop}: ${d.message}`;
                el.setAttribute('data-user-id', d.user_id);
                if (username) el.setAttribute('data-username', username);
                el.setAttribute('data-pickup-id', d.pickup_id || '');
                el.style.cursor = 'pointer';
                el.addEventListener('click', onNotifClick);
                notifBox.appendChild(el);
                notifBox.scrollTop = notifBox.scrollHeight;
                // bump unread badge
                const current = parseInt(notifBadge.innerText || '0') || 0;
                setBadge(current + 1);
            } else if (d.type === 'chat_message') {
                const el = document.createElement('div');
                el.innerText = (d.sender_id === {{ request.user.id }} ? 'You: ' : 'User: ') + d.content;
                chatLog.appendChild(el);
                chatLog.scrollTop = chatLog.scrollHeight;
            }
        };

                sendBtn && sendBtn.addEventListener('click', function(){
            const content = chatInput.value.trim();
            if (!content) return;
            // read selected recipient from notifications box
            const recipient = notifBox.dataset.selectedUser ? parseInt(notifBox.dataset.selectedUser) : null;
            const recipientName = notifBox.dataset.selectedUserName || null;
            const payload = {type: 'chat_message', content: content, recipient_id: recipient, recipient_name: recipientName, bus_id: {% if bus %}{{ bus.id }}{% else %}null{% endif %}};
            driverSocket.send(JSON.stringify(payload));
            chatInput.value = '';
        });

        // when a notification is clicked, mark seen and set selected recipient
        function onNotifClick(){
            const userId = this.getAttribute('data-user-id');
            const pickupId = this.getAttribute('data-pickup-id');
            const username = this.getAttribute('data-username') || null;
            // visually select
            notifBox.querySelectorAll('div').forEach(x => x.style.background = '');
            this.style.background = '#eef';
            notifBox.dataset.selectedUser = userId;
            if (username) notifBox.dataset.selectedUserName = username;
            // mark pickup seen via AJAX so server-side count updates
            if (pickupId) {
                fetch('/api/mark_pickup_seen/', {
                    method: 'POST',
                    headers: {'Content-Type':'application/x-www-form-urlencoded','X-CSRFToken': '{{ csrf_token }}'},
                    body: 'pickup_id=' + encodeURIComponent(pickupId)
                }).then(r=>r.json()).then(data=>{
                    if (data && data.status === 'ok'){
                        // decrement badge
                        const current = parseInt(notifBadge.innerText || '0') || 1;
                        setBadge(Math.max(0, current - 1));
                    }
                }).catch(()=>{});
            }
        }

        // Clear all notifications button
        const clearBtn = document.getElementById('clearAllNotifs');
        if (clearBtn) {
            clearBtn.addEventListener('click', function(){
                if (!confirm('Clear all pickup notifications?')) return;
                fetch('/api/clear_all_pickups/', {
                    method: 'POST',
                    headers: {'Content-Type':'application/x-www-form-urlencoded','X-CSRFToken': '{{ csrf_token }}'},
                    body: ''
                }).then(r=>r.json()).then(data=>{
                    if (data && data.status === 'ok'){
                        // clear UI
                        notifBox.innerHTML = '';
                        setBadge(0);
                    } else {
                        alert('Failed to clear notifications');
                    }
                }).catch(()=>{ alert('Network error'); });
            });
        }
    })();
{% endif %}
</script>

{% endblock %}
